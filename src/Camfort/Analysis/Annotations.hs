{-
   Copyright 2016, Dominic Orchard, Andrew Rice, Mistral Contrastin, Matthew Danish

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
-}
{-# LANGUAGE DeriveDataTypeable #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE TypeSynonymInstances #-}
{-# LANGUAGE FlexibleInstances #-}

module Camfort.Analysis.Annotations where

import Data.Data
import Data.Generics.Uniplate.Operations
import Data.Maybe (isJust)

import Data.Map.Lazy hiding (map)
import Debug.Trace

import Language.Haskell.ParseMonad

import Language.Fortran
import Camfort.Analysis.IntermediateReps
import qualified Camfort.Analysis.StencilSpecification.Syntax as StencilSpec
import qualified Camfort.Analysis.StencilSpecification.Grammar as StencilComment

import qualified Language.Fortran.AST as F

type Report = String

-- Additional "helper" syntax (NOT GENERATED BY PARSER)

-- Loop classifications

data ReduceType = Reduce | NoReduce
data AccessPatternType = Regular | RegularAndConstants | Irregular | Undecidable
data LoopType = Functor ReduceType
               | Gather ReduceType ReduceType AccessPatternType
               | Scatter ReduceType AccessPatternType

data UnitInfo
  = Parametric (String, Int)
  | ParametricUse (String, Int, Int) -- identify particular instantiation of parameters
  | UnitName String
  | Undetermined String
  | Unitless
  | UnitMul UnitInfo UnitInfo
  | UnitPow UnitInfo Double
  deriving (Show, Eq, Ord, Data, Typeable)

{- classify :: Fortran Annotation -> Fortran Annotation
 classify x = -}

type A = Annotation

data Annotation = A { indices        :: [Variable],
                      lives          :: ([Access],[Access]),
                      arrsRead       :: Map Variable [[Expr ()]],
                      arrsWrite      :: Map Variable [[Expr ()]],
                      unitVar        :: Int,
                      number         :: Int,
                      refactored     :: Maybe SrcLoc,
                      successorStmts :: [Int],
                      -- used to indicate when a node is newly introduced
                      newNode        :: Bool,
                      unitInfo       :: Maybe UnitInfo,
                      stencilSpec    ::
                        Maybe -- If defined, either an unprocessed syntax tree
                               (Either StencilComment.Specification
                               -- Or a parser AST of a RegionEnv or SpecDecls
                                (Either StencilSpec.RegionEnv StencilSpec.SpecDecls)),
                      stencilBlock   ::
                        Maybe (F.Block Annotation)
                    }
                   deriving (Eq, Show, Typeable, Data)

liveOut = snd . lives
liveIn = fst . lives

 -- Map Variable [[(Variable,Int)]],

pRefactored :: Annotation -> Bool
pRefactored = isJust . refactored

unitAnnotation =
    A [] ([], []) empty empty 0 0 Nothing [] False Nothing Nothing Nothing
